
// export const hello = () => 'Hello world!';
var readline = require('readline');


const MIN = 0;
const MAX = 2010;
let noRun = false;
let showOutput = false;
let metrics = {
    ok: 0,
    deleted: 0,
    error: 0
}
// const MIN = 4000;
// const MAX = 9335;

// const MIN = 9420
// const MAX = 12000
const notifier = require('node-notifier');
const path = require('path');
const time = new Date().getTime();

const useLine = (line) => {
    const useable = [
        { start: 0, end: 2010},
        { start: 4000, end: 9335},
        { start: 9420, end: 12000},
    ]
    let isOk = false;
    useable.forEach((value, index) => {
        if(line > value.start && line < value.end){
            isOk = true;
        }
    });
    return isOk;
}

const getFileSize = (file) => {
    const
        { spawnSync } = require( 'child_process' ),
        ls = spawnSync( 'du', [ '-hs', file ] );
        const size = ls.stdout.toString().match(/^([^\s])*/);
        return size[0];
}

// String
// notifier.notify('Go empty the dishwasher!');

// Object
// notifier.notify({
//   'title': 'Try out logo',
//   'subtitle': 'Daily Maintenance',
//   'message': 'Go approve comments in moderation!',
//   'icon': path.join(__dirname,   'icon_small.png'),
// //   'contentImage': '../assets/logo_small.png',
// //   'sound': 'ding.mp3',
//   'wait': true
// });

declare interface String {
    getNewLOC(key: string, cntr: any, prevLine: string, keepFnHead: boolean): String;
    getNewLOCX(key: string, cntr: any, prevLine: string, keepFnHead: boolean): String;
}
let countDeleteMe = 0;

let keepFnHead = false;
let deleteBlock = false;
function keepHead(keep) {
    keepFnHead = keep;
}
// String.prototype.getNewLOC = function (key: string, cntr: any, prevLine: string, keepFnHead: boolean): string {
//     const NO_DELETE = '';
//     let line = '';
//     line = this;
//     // console.log(key);
//     // let key = '';
//     let replacement = '\n';
//     if (key === START_DEL_LOC) {
//     }
//     switch (key) {
//         case DO_NOTHING:
//             return line + replacement;
//         default:
//             return line + replacement;
//     }
// }

// String.prototype.getNewLOCX = function (key: string, cntr: any, prevLine: string, keepFnHead: boolean): string {
//     const NO_DELETE = '';
//     let line = this;

//     // let key = '';
//     // key = DO_NOTHING;
//     let replacement = '\n';
//     //   let replacement = '';
//     // if(key !== DO_NOTHING){
//     //     return line + replacement;
//     // }
//     if (key === START_DEL_LOC) {
//     }
//     // key = (key !== SAME_DELETE && key !== START_DEL_LOC && key !==  END_DEL_LOC)  ? DO_NOTHING : key;
//     switch (key) {
//         case DO_NOTHING:
//             return line + replacement;
//         case NO_DELETE:
//             return line + '//' + cntr + replacement;
//         case SAME_DELETE:
//             // function e() {}
//             let checkNamedFn = line.match(REGEX_NAMED_FUNCTION);
//             let checkAnonymFn = line.match(REGEX_ANONYM_FUNCTION);

//             // case: anonymous fn: var l = function() {};
//             if (checkNamedFn !== null || checkAnonymFn !== null) {
//                 return line + ' ' + key + '2' + replacement;
//             } else {
//                 return key + ' ' + line + replacement;
//             }

//         //function e() {}
//         case START_DEL_LOC:
//             //t.prototype.getTypeName = function() {'

//             // '        e.prototype.toString = function() {'
//             let checkPrototype = line.match(/\s*[^\.]+\.prototype\.[^\s]+\s*\=\sfunction\([^\)]*\)\s*\{/);
//             if (checkPrototype !== null) {
//                 // console.log(checkPrototype)
//                 // var o = 
//                 // foobar || somethinToDelete
//                 deleteBlock = true;
//                 let check1 = prevLine.match(/^[\s]*(.*)\s\|\|$/);
//                 if (check1 !== null && check1[1] !== ') ||') {
//                     countDeleteMe++;
//                     return 'function dd(){}' + ';' + replacement;
//                     //  'ddM'+ countDeleteMe + ';' + replacement;
//                 }
//                 let checkPrev = prevLine.match(/^\s*[\?|\:]{1}\s/);
//                 const hasTernaryPrev = checkPrev !== null;
//                 //default
//                 let check = line.match(/^\s*[\?|\:]{1}\s/);
//                 const hasTernary = check !== null;
//                 if (hasTernary) {
//                     countDeleteMe++;
//                     if (check[0].indexOf('?') > -1) {
//                         // return line + '//ex ?' + replacement; 
//                         return check[0] + "'dMX'" + replacement;
//                     } else {
//                         // return line + '//ex :' + replacement; 
//                         return check[0] + "'dMXX'" + ';' + replacement;
//                     }
//                 } else {
//                     //default
//                 }


//                 // t.prototype.getTypeName = function() {' ]
//                 let checkAnoymous = line.match(/^\s*function\s[^\(]+\(/); //\([^\)]*\)\{/);
//                 if (checkAnoymous !== null) {
//                     keepHead(true);
//                     keepFnHead = true;
//                     // return '//' + cntr + key + replacement;
//                     return line + replacement;
//                 } else {
//                     keepHead(false);
//                     let check4lastComma = prevLine.match(/^\s*[^\{|\s}]+\,$/);
//                     if (check4lastComma !== null) {
//                         countDeleteMe++;
//                         return 'function dd(){}' + key + line + replacement;
//                         // return 'dddddM'+ countDeleteMe + key +    line +replacement;
//                     } else {

//                         let checkNamedFn = line.match(/^\s*var\s[^\s]+\s\=\sfunction\s*\(/); //\([^\)]*\)\{/);
//                         if (checkNamedFn !== null) {
//                             keepHead(true);
//                             keepFnHead = true;
//                             // return '//' + cntr + key + replacement;
//                             return line + replacement;
//                         } else {
//                             return key + line + replacement;

//                         }
//                         // return key +    line +replacement;
//                     }
//                 }
//             } else {
//                 deleteBlock = false;
//                 return line + replacement;
//             }
//         case IS_DELETING:
//             if (deleteBlock === true) {
//                 return key + line + replacement;
//             } else {
//                 return line + replacement;
//             }
//         // return '//'+cntr +  key + replacement;
//         case END_DEL_LOC:
//             // if(keepFnHead === true){
//             //     keepHead(false);
//             //     return line + replacement;
//             // } else {

//             //     let check2 =  line.match(/^\s*\}{1}(.+){1}$/);//     \;?\)?[^\s]{1}$/);  //(.+)$/);
//             // if(check2 !== null && check2.length > 1){
//             //     if(check2[1] !== ';' && check2[1] !== ');' && check2[1] !== ','){
//             //     }
//             // }
//             // if(check2 !== null &&check2[1] === ') ||'){
//             //     countDeleteMe++;
//             //     return 'dddM'+ countDeleteMe + ')'+replacement;

//             // }
//             // return '//'+key + line+ replacement;
//             if (deleteBlock) {
//                 deleteBlock = false;
//                 return key + line + replacement;
//             } else {
//                 return line + replacement;
//             }

//         // reutrn 
//         // return key + ' ' +   line +replacement;
//         // }
//         default:
//             return key + ': ' + keepFnHead + ' ' + line + replacement;
//         /*
//     case END_DEL_LOC:
//         let checkEndFn =  line.match(/^\s*\}\;+$/);
//         if(checkEndFn !== null){
//             return '//'+key + line+ replacement;
//         }


//         // let check2 =  line.match(/^\s*\}{1}(.+){1}$/);//     \;?\)?[^\s]{1}$/);  //(.+)$/);
//         // if(check2 !== null && check2.length > 1){
//         //     if(check2[1] !== ';' && check2[1] !== ');' && check2[1] !== ','){
//         //     }
//         // }
//         // if(check2 !== null &&check2[1] === ') ||'){
//         //     countDeleteMe++;
//         //     return 'dddM'+ countDeleteMe + ')'+replacement;

//         // }
//         // return '//'+key + line+ replacement;
//         return line + replacement;
//       case START_DEL_LOC:

//         // t.prototype.getTypeName = function() {' ]
//         let checkAnoymous = line.match(/^\s*[^\s]*\s\=\sfunction/); //\([^\)]*\)\{/);
//         if(checkAnoymous !== null){
//             return '//' + cntr + key + replacement;
//         }
//         return line + replacement;
//         // replace unused function inside ? : with deleteMe
//         /*let check1 = prevLine.match(/^[\s]*(.*)\s\|\|$/);
//         if(check1 !== null &&check1[1] !== '})'){
//         }
//         if(check1 !== null &&check1[1] !== ') ||'){
//             countDeleteMe++;
//              return 'ddM'+ countDeleteMe + ';' + replacement;
//         }
//         let check =  line.match(/^\s*[\?|\:]{1}\s/);
//         const hasTernary = check !== null;
//         if(hasTernary){
//             countDeleteMe++;
//             return  check[0] +'dM'+ countDeleteMe+replacement;
//         } else {
//             //default
//         }*/
//         // case DEL_LOC: 
//         // return line + replacement; 
//         // case IS_DELETING:
//         // return '//'+cntr +  key + replacement;
//         // case SAME_DELETE:
//         // return line + replacement; 

//         //           default:
//         //           return line + replacement;
//         //   return  replacement;
//         // return key +  replacement;
//     }
// };


const testFileBase = 'foo';
const testFileName =  testFileBase + '.js';
const pathX = './assets/';
let replacement = '\n';

const testFileStr = pathX + testFileName;
const fs = require('fs');
const coverageData = JSON.parse(fs.readFileSync('./assets/coverage/coverage-final.json', 'utf8'));
const NEW_FILE = pathX + 'new-' + testFileName;
const BUNDLE_FILE = pathX + 'dist/main.js';
const NEW_FILE2 = pathX + 'new2-' + testFileName;
const DIST_FILE = pathX + 'dist/new-' + testFileBase+'.min.js';
const testFileStrNew = pathX + NEW_FILE;

const updateIndexFile = () => {
    const fs2 = require('fs');
    const indexData = JSON.parse(fs2.readFileSync('./assets/dist/index.html', 'utf8'));

}


var testFile = fs.readFileSync(pathX + testFileName, 'utf8');
const getTargetData = (obj, testFileName) => {
    let key = '';
    let targetData = false;
    Object.keys(obj).forEach(object => {
        if (object.indexOf(testFileName) !== -1) {
            key = object;
        }
    });
    if (key !== '') {
        targetData = obj[key];
    }
    return targetData;
}

function colorize(color, output) {
    return ['\033[', color, 'm', output, '\033[0m'].join('');
}

// KEYS
const DEL_LOC = '//#del';
const START_DEL_LOC = '//#startDel';
const IS_DELETING = '//#isDelete';
const END_DEL_LOC = '//#endDel';
const NO_DELETE = '';
const SAME_DELETE = '//#same';
const DO_NOTHING = '//#xxx';

//const GREEN = '\x1b[32m%s\x1b[0m';


const GREEN = '32';
const RED = '31';
const YELLOW = '33';
const MAGENTA = '35';
const BLUE = '34';
const WHITE = '37';

const REGEX_NAMED_FUNCTION = /^\s*function\s[^\(]+\(\)\s*\{\}\s*$/;
const REGEX_ANONYM_FUNCTION = /^\s*var\s[^\s]+\s*\=\s*function\(\)\s*\{\};*$/;




const coverageObj = getTargetData(coverageData, testFileName);
if (!coverageObj) {
    console.log('no coverage data')
}; //stop program


const fnObj = coverageObj['fnMap'];
const fnObjCov = coverageObj['f'];

// const stObj = coverageObj['statementMap'];
// const stObjCov = coverageObj['s'];

const bObj = coverageObj['branchMap'];
const bObjCov = coverageObj['b'];
// console.log(bObj[0]);
// console.log(bObjCov[0]);
// console.log(bObj[0].locations[0]);
// console.log(bObj[0].locations[1]);
// console.log('***')
// console.log(bObj[1]);
// console.log(bObjCov[1]);
// console.log(bObj[1].locations[0]);
// console.log(bObj[1].locations[1]);
const sObj = coverageObj['statementMap'];
const sObjCov = coverageObj['s'];


coverageObj['s'] //statements, ohne funktionen, line number not the same
// console.log(coverageObj['branchMap'][2]);
const deletableStatements = [];
const getRemovableStatements = (obj, objCov) => {
    if(noRun){
        return;
    }
    Object.keys(obj).forEach((recordID) => {
        const statement = obj[recordID];
        const isCovered = objCov[recordID] > 0;
        // const id = Number.parseInt(recordID);
        let multiLine = true;
        if (!isCovered) {
            if (statement['start']['line'] === statement.end.line) {
                multiLine = false;
            }
            const newEntry = {
                'start': statement['start']['line'],
                'multiline': multiLine,
                'location': statement
            }
            deletableStatements.push(newEntry);
        }

    });
}
///////////////////////
// console.log('==== get removable statements');
if(!noRun){

    getRemovableStatements(coverageObj['statementMap'], coverageObj['s'])
}

const getRemovableLines = (obj, objCov, type) => {
    let removeLinesArray = [];
    let countRecords = 0;
    // console.log('---beginn---');
    // console.log(removeLinesArray.length);
    // console.log(countRecords);
    if (type == 's') {
        Object.keys(obj).forEach(recordID => {
            // not necessary gleiche reihenfolge oder one-line
            // start und end vergleichen
            // z.b. zeile 3 nicht gecover
            let loc = obj[recordID];
            if (objCov[recordID] === 0) {
                // console.log(objCov[recordID] + ' => ');
                // console.log(obj[recordID]);
                // console.log('---');
                removeLinesArray.push(loc)
                countRecords++;

            }
        })
        // console.log(removeLinesArray);
    }

    // Object.keys(obj).forEach(recordID => {
    //     // countRecords++;
    //     let loc = obj[recordID]['loc'];
    //     if (type === 'b' &&
    //         (objCov[recordID][0] === 1 && objCov[recordID][1] === 0) &&
    //         (obj[recordID].locations[0]['start']['line'] == obj[recordID].locations[0].end.line)
    //     ) {
    //         // if(objCov[recordID] > 1){
    //         // console.log('start: '+ loc['start']['line'])
    //         // console.log(objCov[recordID])
    //         // console.log(obj[recordID].locations)
    //         // }
    //     }
    //     if (objCov[recordID] === 0 && countRecords < 10) {
    //         countRecords++;
    //         console.log(countRecords < 10)
    //         console.log('push: ' + countRecords)
    //         removeLinesArray.push([loc['start']['line'], loc.end.line])
    //     }
    // })
    // console.log('count2: ' + removeLinesArray.length);
    return removeLinesArray;
}

const getNewRecord = (currentIndex, removeLines, cntr) => {
    let newIndex = currentIndex
    // get new record of removable lines
    if (newIndex < removeLinesLen - 1) {
        newIndex++;
        while (removeLines[newIndex][0] < cntr) {
            newIndex++
        }
    }
    return newIndex;
}

const writeNewLine = (fs, file, newLine, mode?) => {
    // var mod = cntr == 0 ? 'w' : 'a';
    const ADD_MODE = { encoding: 'utf8', flag: 'a' };
    // fs.writeFileSync(file, '', )
    fs.writeFileSync(file, newLine, ADD_MODE);
}

// let fRemoveLines = getRemovableLines(fnObj, fnObjCov, 'f');
// let bRemoveLines = getRemovableLines(bObj, bObjCov, 'b');
let sRemoveLines = getRemovableLines(sObj, sObjCov, 's');
let sRemoveLinesOrder = [];

// order lines
// sRemoveLines.forEach(item => {
//     sRemoveLinesOrder.push(item['start']['line'])
// })

// reset file
if (fs.existsSync(NEW_FILE)) {
fs.unlinkSync(NEW_FILE);
}
console.log('file deleted')
fs.writeFileSync(NEW_FILE, '//xx\n', { encoding: 'utf8', flag: 'w+' });
console.log('new file created');
var readline = require('readline');
var cntr = 0;

var rl = readline.createInterface({
    input: fs.createReadStream(testFileStr),
});

let isDeleting = false;
// let i = 2; //@todo: why not 0
let i = 0;
let removeLinesLen = sRemoveLines.length;

const STATUS_OK = 0;
const STATUS_REMOVED = 1;
const STATUS_ERROR = 2;

let prevLine = '';
let nextDeletableLine = 0;
let indexDeletableLine = 0;
let lineStatus = 0;
let removeBlockIndention = 0;
const analyze = (line) => {
    lineStatus = STATUS_OK;
    // console.log(sRemoveLines)
    // let start = sRemoveLines[next];

    // todo: einzeiler löschen, wenn start/ende oder fnDelete not running
    if (cntr === 0) {
        nextDeletableLine = sRemoveLines[nextDeletableLine];
        // console.log('next: ' + JSON.stringify(nextDeletableLine));
        // console.log(MAGENTA, 'I am cyan');
    }
    let newLine = '';
    newLine = line;
    // let removeBlockIndention = 0;
    // console.log(removeBlockIndention)
    if (cntr++ >= 0 && removeBlockIndention === 0) {
        // console.log(cntr)
        // let newLine = '';
        if (nextDeletableLine['start']['line'] === cntr) {
            // if (cntr < 100){
            //     if(nextDeletableLine['start']['line'] == nextDeletableLine['end']['line']){
            //         let startCol = nextDeletableLine['start']['column'];
            //         let endCol = nextDeletableLine['end']['column'];
            //         let diff = endCol-startCol;

            //         // console.log(nextDeletableLine);
            //         // console.log(WHITE + YELLOW,cntr+' :', line.substring(startCol, endCol))
            //     }
            //     // line.substring(nextDeletableLine['line'].start.col)
            // }
            // between 1800 und 2000
            console.log(prevLine)
            // 2009-2025 + 2971-2983
            if (useLine(cntr)){

            // if (cntr < 150000){
            // if ((cntr < 2009 || cntr > 2025) &&  (cntr < 2971 && cntr || 2983)) {

                // not prev line has =
                if (prevLine.match(/.*[^\=]{1}$/)) {
                    //NOT: line ends with ?|:|{|(|[
                    if (line.match(/.*[^\?|\:|\{|\(|\[]{1}$/)) {
                        //NOT: line starts with var
                        if (line.match(/^\s*var\s[^\s]*\s*\=\s*.*$/)) {
                            lineStatus = STATUS_ERROR;
                             newLine = line + '//#1';
                        } else {
                            //NOT: line starts with . (TODO)
                            // if (line.match(/^\s[^\.]{1}.*$/)) {
                            if (line.match(/^\s*[a-z]+\s*$/)) {
                                // console.log(WHITE + RED, cntr + ': ', line);
                            } else {
                                if (line.match(/^.*[^\;]{1}\s*$/)) {
                                } else {
                                    if (line.match(/^\s*return\s*[^\;]*\;$/)) {
                                        // console.log(WHITE + MAGENTA, cntr + ': ', line);
                                    }
                                    else {
                                        lineStatus = STATUS_REMOVED;

                                        // delete line
                                        // newLine = '//deleted: ' + cntr + line;
                                        newLine = ''; //deleted: ' + cntr + line;
                                        
                                    }

                                }

                            }

                            // writeNewLine(fs, NEW_FILE, line + '\n', false);

                        }

                    } else {
                        lineStatus = STATUS_ERROR;
                        let ifCheck = line.match(/^(\s*)if.*/)
                        console.log(ifCheck);
                        if(ifCheck && ifCheck.length > 0 && removeBlockIndention === 0){
                            removeBlockIndention = ifCheck[1].length;
                            console.log(removeBlockIndention);
                            newLine = '//99';
                        } else {
                            newLine = line + '//#2|' + line.match(/^(\s*)/)[1].length;
                        }
                        //detect if => count whitespace + make flag, delete until closing
                    }

                } else {
                    lineStatus = STATUS_ERROR;
                    newLine = line + '//#3';

                }
            }

            // create an Array of deletable stuff
            const deletableEntry = sRemoveLines[indexDeletableLine];
            if (deletableEntry) {

                // deactivated
                if (deletableEntry.multiline === false && cntr == -234) {
                    // console.log('--- line '+ cntr);
                    // console.log('old:'+ line);
                    // string drumherum nehmen
                    let start = deletableEntry.location.start.column;
                    let end = deletableEntry.location.end.column
                    line = line.substring(0, start) + line.substring(end, line.length);
                    let replaceable = line.substring(deletableEntry.location.start.column, deletableEntry.location.end.column);

                    // var t = ;
                    let checkNamedVar = line.match(/^\s*var\s([^\s]+){1}\s\=\s+\;/);
                    // console.log(checkNamedVar);
                    if (checkNamedVar !== null) {
                        if (checkNamedVar.length > 0) {
                            line = '';
                        }
                    }
                    // if(replaceable === 'r'){
                    //     line.substring(deletableEntry.location.start.column, deletableEntry.location.end.column);
                    //     console.log(deletableEntry);
                    // }
                    // if(replaceable !== undefined){

                    //     line = line.replace(replaceable);
                    // } else {
                    //     console.log('hier: ');
                    //     console.log(deletableEntry);
                    // }

                    // console.log('new:'+ line.substring(deletableEntry.location.start.column, deletableEntry.location.end.column))
                    // console.log(deletableStatements[indexDeletableLine]);

                }
                // console.log(cntr);
                indexDeletableLine++;
                if (sRemoveLines[indexDeletableLine]) {

                    nextDeletableLine = sRemoveLines[indexDeletableLine];

                } else {
                    // console.log('else: ' + indexDeletableLine)
                }
            }

        }

        // }
        // WHITE + MAGENTA, cntr + ': ', line
        let color = WHITE;
        switch (lineStatus) {
            case STATUS_ERROR:
                color = RED;
                metrics.error++;
                break;
            case STATUS_REMOVED: 
                color = YELLOW; 
                metrics.deleted++;
                break;
            default: 
                color = WHITE;
                metrics.ok++;
        }
        if(showOutput){

            readline.cursorTo(process.stdout, 0);
            // process.stdout.write(' ' + colorize(color, cntr.toString()));
            process.stdout.write(
                'line:  ' + colorize(WHITE, cntr.toString()) +
                '| ok: ' + colorize(GREEN, metrics.ok.toString()) +
                '| deleted: ' + colorize(YELLOW, metrics.deleted.toString()) +
                '| error: ' + colorize(RED, metrics.error.toString()) 
                );
        }
        writeNewLine(fs, NEW_FILE, newLine + '\n', false);
        // let action = NO_DELETE;
        // if(cntr === 1){
        //     action = IS_DELETING;

        // }

        // if(isDeleting){
        //     action = (start[1] == cntr) ? END_DEL_LOC : IS_DELETING;
        // } else if(start[0] == cntr){
        //     action = (start[1] == start[0]) ? SAME_DELETE : START_DEL_LOC ;
        // }
        // isDeleting = (action == START_DEL_LOC || action == SAME_DELETE) ? true : isDeleting;

        // // action = action === SAME
        // let newLine = line.getNewLOC(action, cntr, prevLine, keepFnHead);
        // if(newLine !== ''){
        //     writeNewLine(fs, NEW_FILE, newLine, keepFnHead);
        // }

        // // update new record
        // if((action == END_DEL_LOC) || (action == SAME_DELETE)){
        //     i = getNewRecord(i, removeLines, cntr);
        //     isDeleting = false;
        // }
    } else {
        if(removeBlockIndention > 0){
            // console.log(removeBlockIndention);

            let countSpaces = line.match(/^(\s*)\}/);
            // console.log(countSpaces);
            if(countSpaces && countSpaces.length > 0){
                if(countSpaces[1].length === removeBlockIndention){
                    console.log(line)
                    removeBlockIndention = 0;
                    // newLine = line + '//#91|' + line.match(/^(\s)*.*/)[0].length;
                }
                else {
                    console.log(line)
                    // newLine = line + '//#92|' + line.match(/^(\s)*.*/)[0].length;
                }
            }else {
                console.log(line)
                // newLine = line + '//#93|' + line.match(/^(\s)*.*/)[0].length;
            }
            newLine = '//98';
            writeNewLine(fs, NEW_FILE, newLine + '\n', false);
        }

        // if(removeBlockIndention > 0){

        // }
        // removeBlockIndention = ifCheck[0].length;
    }
    prevLine = line;

};
if(!noRun){

    rl.on('line', analyze);
}

prevLine = '';
rl.on('close', () => {

    console.log('compress');
    var compressor = require('node-minify');

    // Using Google Closure Compiler
    // compressor.minify({
    //     compressor: 'gcc',
    //     input: NEW_FILE,
    //     output: NEW_FILE2,
    //     options: {
    //         // createSourceMap: true,
    //         rewrite_polyfills: false,
    //         compilation_level: 'ADVANCED_OPTIMIZATIONS',
    //         language: 'ECMASCRIPT6'
    //         // ... // See more information link below
    //     },
    //     callback: function (err, min) { }
    // });
    console.log('copy')
    
    fs.copyFile(NEW_FILE, DIST_FILE, (err) => {
        if (err) throw err;
        const time2 = new Date().getTime();
        // var cp = require('child_process')
        // var grep = cp.exec('du -hs optimizer/assets/dist/new-foo.min.js');
        // console.log(Object.keys(grep));
        // grep.forEach((i,v) => {
        //     console.log(i);
        //     console.log(v);
        // })
        // const exec = require('child_process').exec;
        
        
        
        // execPromise('du -hs optimizer/assets/dist/new-foo.min.js')
        //         .then((aaa) => console.log(aaa), () => false);
        // exec("du -hs optimizer/assets/dist/new-foo.min.jes", (err, stdout, stderr) => console.log(stdout))
        console.log(NEW_FILE2 + ' was copied to' + DIST_FILE);
        // const
        // { spawnSync } = require( 'child_process' ),
        // ls = spawnSync( 'du', [ '-hs', './assets/dist/new-foo.min.js' ] );
        // //../assets/dist/new-foo.min.js
        const sizeStart = getFileSize('./assets/foo.js').match(/(\d*)/)[0];
        const sizeEnd = getFileSize('./assets/dist/new-foo.min.js').match(/(\d*)/)[0];
        const sizeDiff = (100*sizeEnd)/sizeStart;

        
        notifier.notify(' ❤️✔️ DONE ⌛' + ((time2- time)/1000) + ' 💾 ' + getFileSize('./assets/foo.js') + ' ⬇️ ' +  getFileSize('./assets/dist/new-foo.min.js') + ' ('+sizeDiff+'%)'+'\n metrics: ✔️' +  metrics.ok + '❌ ' + metrics.deleted + '⚠️ '+ metrics.error);
    

    });
});
// console.log('copy file');